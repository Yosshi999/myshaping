from _typeshed import Incomplete
from enum import Enum
from typing import Any, AsyncGenerator, Callable, Generator, Sequence, TextIO, TypeVar, overload

__all__ = ['ForwardRefPolicy', 'TypeHintWarning', 'typechecked', 'check_return_type', 'check_argument_types', 'check_type', 'TypeWarning', 'TypeChecker', 'typeguard_ignore']

def typeguard_ignore(f: _F) -> _F: ...
T_CallableOrType = TypeVar('T_CallableOrType', bound=Callable[..., Any])

class ForwardRefPolicy(Enum):
    ERROR = 1
    WARN = 2
    GUESS = 3

class TypeHintWarning(UserWarning): ...

class _TypeCheckMemo:
    globals: Incomplete
    locals: Incomplete
    def __init__(self, globals: dict[str, Any], locals: dict[str, Any]) -> None: ...

class _CallMemo(_TypeCheckMemo):
    func: Incomplete
    func_name: Incomplete
    is_generator: Incomplete
    arguments: Incomplete
    type_hints: Incomplete
    def __init__(self, func: Callable, frame_locals: dict[str, Any] | None = None, args: tuple = None, kwargs: dict[str, Any] = None, forward_refs_policy=...) -> None: ...

def check_type(argname: str, value, expected_type, memo: _TypeCheckMemo | None = None, *, globals: dict[str, Any] | None = None, locals: dict[str, Any] | None = None) -> None: ...
def check_return_type(retval, memo: _CallMemo | None = None) -> bool: ...
def check_argument_types(memo: _CallMemo | None = None) -> bool: ...

class TypeCheckedGenerator:
    def __init__(self, wrapped: Generator, memo: _CallMemo) -> None: ...
    def __iter__(self): ...
    def __next__(self): ...
    def __getattr__(self, name: str) -> Any: ...
    def throw(self, *args): ...
    def close(self) -> None: ...
    def send(self, obj): ...

class TypeCheckedAsyncGenerator:
    def __init__(self, wrapped: AsyncGenerator, memo: _CallMemo) -> None: ...
    def __aiter__(self): ...
    def __anext__(self): ...
    def __getattr__(self, name: str) -> Any: ...
    def athrow(self, *args): ...
    def aclose(self): ...
    async def asend(self, obj): ...

@overload
def typechecked(*, always: bool = False) -> Callable[[T_CallableOrType], T_CallableOrType]: ...
@overload
def typechecked(func: T_CallableOrType, *, always: bool = False) -> T_CallableOrType: ...

class TypeWarning(UserWarning):
    func: Incomplete
    event: Incomplete
    error: Incomplete
    frame: Incomplete
    def __init__(self, memo: _CallMemo | None, event: str, frame, exception: str | TypeError) -> None: ...
    @property
    def stack(self): ...
    def print_stack(self, file: TextIO = None, limit: int = None) -> None: ...

class TypeChecker:
    all_threads: Incomplete
    annotation_policy: Incomplete
    def __init__(self, packages: str | Sequence[str], *, all_threads: bool = True, forward_refs_policy: ForwardRefPolicy = ...) -> None: ...
    @property
    def active(self) -> bool: ...
    def should_check_type(self, func: Callable) -> bool: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None: ...
    def __call__(self, frame, event: str, arg) -> None: ...
