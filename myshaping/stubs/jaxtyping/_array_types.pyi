import enum
import re
from ._errors import AnnotationError as AnnotationError
from ._storage import get_shape_memo as get_shape_memo, get_treeflatten_memo as get_treeflatten_memo, get_treepath_memo as get_treepath_memo, set_shape_memo as set_shape_memo
from _typeshed import Incomplete
from dataclasses import dataclass
from typing import Any, Literal, NoReturn, Union

def get_array_name_format(): ...
def set_array_name_format(value) -> None: ...

class _AnyDtype:
    pass
class _DimType(enum.Enum):
    named = ...
    fixed = ...
    symbolic = ...

@dataclass(frozen=True)
class _NamedDim:
    name: str
    broadcastable: bool
    treepath: Any

@dataclass(frozen=True)
class _NamedVariadicDim:
    name: str
    broadcastable: bool
    treepath: Any

@dataclass(frozen=True)
class _FixedDim:
    size: int
    broadcastable: bool

@dataclass(frozen=True)
class _SymbolicDim:
    elem: Any
    broadcastable: bool

@dataclass(frozen=True)
class _AnonymousDim:
    pass

@dataclass(frozen=True)
class _AnonymousVariadicDim:
    pass

_AbstractDimOrVariadicDim = Union[
    _AnonymousDim,
    _AnonymousVariadicDim,
    _NamedDim,
    _NamedVariadicDim,
    _FixedDim,
    _SymbolicDim,
]
_AbstractDim = Union[_AnonymousDim, _NamedDim, _FixedDim, _SymbolicDim]

class _MetaAbstractArray(type):
    def make_transparent(cls) -> None: ...
    def __instancecheck__(cls, obj: Any) -> bool: ...
    def __instancecheck_str__(cls, obj: Any) -> str: ...

class AbstractArray(metaclass=_MetaAbstractArray):
    dtype: type['AbstractDtype']
    array_type: Any
    dim_str: str
    dtypes: list[str]
    dims: tuple[_AbstractDimOrVariadicDim, ...]
    index_variadic: int | None
    def __new__(cls, *args, **kwargs) -> None: ...

class _MetaAbstractDtype(type):
    def __instancecheck__(cls, obj: Any) -> NoReturn: ...
    def __getitem__(cls, item: tuple[Any, str]): ...

class AbstractDtype(metaclass=_MetaAbstractDtype):
    dtypes: _AnyDtype | list[str | re.Pattern]
    def __init__(self, *args, **kwargs) -> None: ...
    def __init_subclass__(cls, **kwargs) -> None: ...


from typing import TypeVar, Generic
_ArrayType = TypeVar("_ArrayType")
_Shape = TypeVar("_Shape", bound=str)
class UInt2(Generic[_ArrayType, _Shape]): ...
class UInt4(Generic[_ArrayType, _Shape]): ...
class UInt8(Generic[_ArrayType, _Shape]): ...
class UInt16(Generic[_ArrayType, _Shape]): ...
class UInt32(Generic[_ArrayType, _Shape]): ...
class UInt64(Generic[_ArrayType, _Shape]): ...
class Int2(Generic[_ArrayType, _Shape]): ...
class Int4(Generic[_ArrayType, _Shape]): ...
class Int8(Generic[_ArrayType, _Shape]): ...
class Int16(Generic[_ArrayType, _Shape]): ...
class Int32(Generic[_ArrayType, _Shape]): ...
class Int64(Generic[_ArrayType, _Shape]): ...
class Float8e4m3b11fnuz(Generic[_ArrayType, _Shape]): ...
class Float8e4m3fn(Generic[_ArrayType, _Shape]): ...
class Float8e4m3fnuz(Generic[_ArrayType, _Shape]): ...
class Float8e5m2(Generic[_ArrayType, _Shape]): ...
class Float8e5m2fnuz(Generic[_ArrayType, _Shape]): ...
class BFloat16(Generic[_ArrayType, _Shape]): ...
class Float16(Generic[_ArrayType, _Shape]): ...
class Float32(Generic[_ArrayType, _Shape]): ...
class Float64(Generic[_ArrayType, _Shape], AbstractArray):
    array_type: _ArrayType
    dim_str: _Shape

class Complex64(Generic[_ArrayType, _Shape]): ...
class Complex128(Generic[_ArrayType, _Shape]): ...

class Bool(Generic[_ArrayType, _Shape]): ...
class UInt(Generic[_ArrayType, _Shape]): ...
class Int(Generic[_ArrayType, _Shape]): ...
class Integer(Generic[_ArrayType, _Shape]): ...
class Float(Generic[_ArrayType, _Shape]): ...
class Complex(Generic[_ArrayType, _Shape]): ...
class Inexact(Generic[_ArrayType, _Shape]): ...
class Real(Generic[_ArrayType, _Shape]): ...
class Num(Generic[_ArrayType, _Shape]): ...
class Shaped(Generic[_ArrayType, _Shape]): ...
class Key(Generic[_ArrayType, _Shape]): ...


def make_numpy_struct_dtype(dtype: "np.dtype", name: str): ...
